<?php
App::import('Vendor', 'Spyc', array('file' => 'spyc/spyc.php')) ;

class MobileIp extends Model 
{
  var $useTable = false ;
  
	function find($conditions = null, $fields = array(), $order = null, $recursive = null)
  {
    if ( $conditions != 'range' )
      return parent::find($conditions, $fields, $order, $recursive) ;
  
    $file = Set::extract($fields, 'file') ;
    if (empty($file)) {
      $file = ROOT . DS . APP_DIR . DS .'plugins/mobileip/config/mobile_ips.yml' ;
    }

    if ( !file_exists($file) )
      return false ;

    $cacheDir = $this->getCacheDir();
    $folder = new Folder($cacheDir);
    $folder->create($cacheDir, 0777);

    $cacheFile = $this->getCacheFile();
    if (file_exists($cacheFile) &&
        ($this->_getLastModified($file) <= filemtime($cacheFile))) {
      return include($cacheFile);
    }
      
    $mobile_ips =& Spyc::YAMLLoad($file);
    if ( !is_array($mobile_ips) ) 
      return false ;
      
    $data = $this->_get_ranges($mobile_ips) ;
   
    $file = new File($cacheFile, true);
    $file->write($data);
    $file->close();

    return include($cacheFile);
  }

  function getCacheDir()
  {
    $cacheDir = Configure::read('MobileIp.cacheDir');
    if (is_null($cacheDir)) {
      $cacheDir = CACHE . 'mobile_ip_component';
    }
    return $cacheDir;
  }

  function getCacheFile()
  {
    $cacheFile = Configure::read('MobileIp.cacheFile');
    if (is_null($cacheFile)) {
      $cacheFile = 'range.php';
    }
    return $this->getCacheDir() . DS . $cacheFile;
  }
  
  function _getLastModified($file)
  {
    return filemtime($file);
  }

  function _get_ranges(&$config)
  {
    // get all ip ranges
    $ranges = array();
    foreach ($config as $carrier => $carrier_ips) {
      foreach ($carrier_ips as $cidr) {
        $cidr = @Net_IPv4::parseAddress($cidr);
        $ranges[] = array(
          'broadcast' => $this->ip2double($cidr->broadcast),
          'carrier'   => $carrier,
          'network'   => $this->ip2double($cidr->network));
      }
    }

    // sort
    usort($ranges, array($this, 'compareByNetwork'));

    // unite sequent ip range
    $l = count($ranges);
    $cur =& $ranges[0];
    for ($i = 1; $i < $l; $i++) {
      $next =& $ranges[$i];
      $condition = ($cur['broadcast']+1) === $next['network'] &&
        $cur['carrier'] === $next['carrier'];
      if ($condition) {
        $cur['broadcast'] = $next['broadcast'];
        unset($ranges[$i]);
      } else {
        $cur =& $ranges[$i];
      }
    }
    $ranges = array_values($ranges);

    // compile data
    $retval = "<?php\n".
              "// auto-generated by %s\n".
              "// date: %s\n".
              "return %s;\n";
    $retval = sprintf($retval,
      __CLASS__, date('Y/m/d H:i:s'), var_export($ranges, true));

    return $retval;
  }

  function compareByNetwork($a, $b)
  {
    if ($a['network'] === $b['network']) {
      return 0;
    } else if ($a['network'] < $b['network']) {
      return -1;
    } else {
      return 1;
    }
  }

  function ip2double($addr)
  {
    return (double)(sprintf('%u', ip2long($addr)));
  }
}
